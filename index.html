<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculator</title>
</head>
<body>
    <div id="display">123</div>
    <button id="num">0</button>
    <button id="num">1</button>
    <button id="num">2</button>
    <button id="num">3</button>
    <button id="num">4</button>
    <button id="num">5</button>
    <button id="num">6</button>
    <button id="num">7</button>
    <button id="num">8</button>
    <button id="num">9</button>
    <button id="operator">+</button>
    <button id="operator">-</button>
    <button id="operator">x</button>
    <button id="operator">/</button>
    <button id="equal">=</button>
    <button id="clear">clear</button>


    <script>
        function add(num1, num2) {
            return num1 + num2;
        }

        function subtract(num1, num2) {
            return num1 - num2;
        }

        function multiply(num1, num2) {
            return num1 * num2;
        }

        function divide(num1, num2) {
            return num1 / num2;
        }

        function operate(num1, num2, operator) {
            switch(operator) {
                case '+':
                    return add(num1, num2);
                    break;
                case '-':
                    return subtract(num1, num2);
                    break;
                case '*':
                case 'x':
                    return multiply(num1, num2);
                    break;
                case '/':
                    return divide(num1, num2);
                    break;
                // Add default case? //
            }
        }

        const buttons = document.querySelectorAll('button');
        const display = document.querySelector('#display');

        let userNums = []; // Initialization ives outside of event listener otherwise it gets overwritten each click.
        let userNumsJoined = [];
        let num1;   // Creating variables for all of these then overwriting their values within the if statements so they can be seen anywhere in the code.
        let num2;
        let operator;

        buttons.forEach((btn) => {
            btn.addEventListener("click", (e) => {
                let target = e.target.innerText;
                let targetType = e.target.id;

                switch (targetType) {
                    case 'num':
                        userNums.push(target);
                        display.textContent = +userNums.join(''); // Display joined number as user clicks nums. Does not save into a variable yet, though. Do this during operator step. Otherwise we wouldn't be able to delineate between num1 creation and num2 creation.
                        num1 = +userNums.join('');  // Notice it's num1 =, not let num1 =. We are overwriting its value so it can be seen everywhere. // Unary + converts num1 from string to number
                        console.log('num1 =' + num1);
                        break;
                    case 'operator':
                        operator = e.target.innerText;
                        display.textContent = operator;

                        userNumsJoined.push(num1);
                        console.log('userNumsJoined = ' + userNumsJoined);

                        num2 = userNumsJoined.reduce((total, current) => {  // using reduce got around the issue of initializing a value for each operator when trying to use num2 =+ num1 (or =* or whatever, since they would require diff num2 starting values to work). the first value of reduce just defaults to the first thing in the array.
                            switch (target) {
                                case '+':                            
                                    return total + current;
                                    break;
                                case '-':
                                    return total - current;
                                    break;
                                case 'x':
                                    return total * current;
                                case '/':
                                    return total / current;
                                    break;
                            }
                        });

                        console.log('num2 after operator = ' + num2);
                        userNums = [];              // Make userNums empty array everywhere again.
                        break;
                    case 'equal':
                        userNums = [];

                        display.textContent = operate(num1, num2, operator);

                        console.log('num2 after equal =' + num2);
                        console.log('final value = ' + operate(num1, num2, operator));
                        break;
                    case 'clear':
                        num1 = 0;
                        num2 = 0;
                        display.textContent = '0';
                        // clear doesn't work right, don't want to initialize to 0
                };
            });
        });

// Step 6
// Need the program to know when numbers end and operator starts.
// Perhaps add another id to the operators to distinguish from numbers?
// And another to the numbers to distinguish from the operators?
// What happens if they press operators in a row? Ignore somehow?
// What if they start with operator instead of a number?
        // Do nothing with an operator until a num1 is stored?
        // if num1 === nullish, nothing?


// If click a number, store it. 
// If click another numbers, store it, and concat. Use rest param??
    // Already stored as string. After concat, store as num
// If click operator, store it
    // If click another operator, override first?
        // Maybe have this be extended function, come back later
// Then when click number again, store, concat, conver to num again
// When click =, run operate function

// Do we need another function that store all values then runs operate within it?
    </script>
</body>
</html>